"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isEqual = require("../common/js/lodash.isequal");
const utils = require("./utils");
const keypairs = require("ripple-keypairs");
const binaryCodec = require("ripple-binary-codec");
const ripple_hashes_1 = require("ripple-hashes");
const bignumber_js_1 = require("bignumber.js");
const common_1 = require("../common");
const validate = utils.common.validate;
function computeSignature(tx, privateKey, signAs) {
    const signingData = signAs
        ? binaryCodec.encodeForMultisigning(tx, signAs)
        : binaryCodec.encodeForSigning(tx);
    return keypairs.sign(signingData, privateKey);
}
function signWithKeypair(api, txJSON, keypair, options = {
    signAs: ''
}) {
    validate.sign({ txJSON, keypair });
    const tx = JSON.parse(txJSON);
    if (tx.TxnSignature || tx.Signers) {
        throw new utils.common.errors.ValidationError('txJSON must not contain "TxnSignature" or "Signers" properties');
    }
    checkFee(api, tx.Fee);
    const txToSignAndEncode = Object.assign({}, tx);
    txToSignAndEncode.SigningPubKey = options.signAs ? '' : keypair.publicKey;
    if (options.signAs) {
        const signer = {
            Account: options.signAs,
            SigningPubKey: keypair.publicKey,
            TxnSignature: computeSignature(txToSignAndEncode, keypair.privateKey, options.signAs)
        };
        txToSignAndEncode.Signers = [{ Signer: signer }];
    }
    else {
        txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, keypair.privateKey);
    }
    const serialized = binaryCodec.encode(txToSignAndEncode);
    checkTxSerialization(serialized, tx);
    return {
        signedTransaction: serialized,
        id: ripple_hashes_1.computeBinaryTransactionHash(serialized)
    };
}
function checkTxSerialization(serialized, tx) {
    const decoded = binaryCodec.decode(serialized);
    if (!decoded.TxnSignature && !decoded.Signers) {
        throw new utils.common.errors.ValidationError('Serialized transaction must have a TxnSignature or Signers property');
    }
    delete decoded.TxnSignature;
    delete decoded.Signers;
    if (!tx.SigningPubKey) {
        delete decoded.SigningPubKey;
    }
    if (!isEqual(decoded, tx)) {
        const error = new utils.common.errors.ValidationError('Serialized transaction does not match original txJSON');
        error.data = {
            decoded,
            tx
        };
        throw error;
    }
}
function checkFee(api, txFee) {
    const fee = new bignumber_js_1.BigNumber(txFee);
    const maxFeeDrops = common_1.xrpToDrops(api._maxFeeXRP);
    if (fee.greaterThan(maxFeeDrops)) {
        throw new utils.common.errors.ValidationError(`"Fee" should not exceed "${maxFeeDrops}". ` +
            'To use a higher fee, set `maxFeeXRP` in the RippleAPI constructor.');
    }
}
function sign(txJSON, secret, options, keypair) {
    if (typeof secret === 'string') {
        validate.sign({ txJSON, secret });
        return signWithKeypair(this, txJSON, keypairs.deriveKeypair(secret), options);
    }
    else {
        if (!keypair && !secret) {
            throw new utils.common.errors.ValidationError('sign: Missing secret or keypair.');
        }
        return signWithKeypair(this, txJSON, keypair ? keypair : secret, options);
    }
}
exports.default = sign;
//# sourceMappingURL=sign.js.map