"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bip32 = require("bip32");
const bip39 = require("bip39");
const isHex = require("is-hex");
const rippleKeyPair = require("ripple-keypairs");
const defaultDerivationPath = "m/44'/144'/0'/0/0";
class Wallet {
    constructor(publicKey, privateKey) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
    }
    static getDefaultDerivationPath() {
        return defaultDerivationPath;
    }
    static generateRandomWallet(entropy = undefined) {
        if (entropy && !isHex(entropy)) {
            return undefined;
        }
        const mnemonic = entropy == undefined
            ? bip39.generateMnemonic()
            : bip39.entropyToMnemonic(entropy);
        const derivationPath = Wallet.getDefaultDerivationPath();
        const wallet = Wallet.generateWalletFromMnemonic(mnemonic, derivationPath);
        return wallet == undefined
            ? undefined
            : { wallet: wallet, mnemonic: mnemonic, derivationPath: derivationPath };
    }
    static generateWalletFromMnemonic(mnemonic, derivationPath = Wallet.getDefaultDerivationPath()) {
        if (!bip39.validateMnemonic(mnemonic)) {
            return undefined;
        }
        const seed = bip39.mnemonicToSeedSync(mnemonic);
        const masterNode = bip32.fromSeed(seed);
        const node = masterNode.derivePath(derivationPath);
        const publicKey = Wallet.hexFromBuffer(node.publicKey);
        const privateKey = Wallet.hexFromBuffer(node.privateKey);
        return new Wallet(publicKey, "00" + privateKey);
    }
    static generateWalletFromSeed(seed) {
        try {
            const keyPair = rippleKeyPair.deriveKeypair(seed);
            return new Wallet(keyPair.publicKey, keyPair.privateKey);
        }
        catch (exception) {
            return undefined;
        }
    }
    getPublicKey() {
        return this.publicKey;
    }
    getPrivateKey() {
        return this.privateKey;
    }
    getAddress() {
        return rippleKeyPair.deriveAddress(this.getPublicKey());
    }
    sign(hex) {
        if (!isHex(hex)) {
            return undefined;
        }
        return rippleKeyPair.sign(hex, this.getPrivateKey());
    }
    verify(message, signature) {
        if (!isHex(signature) || !isHex(message)) {
            return false;
        }
        try {
            return rippleKeyPair.verify(message, signature, this.getPublicKey());
        }
        catch (error) {
            return false;
        }
    }
    static hexFromBuffer(buffer) {
        return buffer.toString("hex").toUpperCase();
    }
}
exports.default = Wallet;
//# sourceMappingURL=wallet.js.map